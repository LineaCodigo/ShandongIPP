/**
 * bxSlider v4.2.12
 * Copyright 2013-2015 Steven Wanderski
 * Written while drinking Belgian ales and listening to jazz
 * Licensed under MIT (http://opensource.org/licenses/MIT)
 */

;(function($) {

  var defaults = {

    // GENERAL
    mode: 'horizontal',
    slideSelector: '',
    infiniteLoop: true,
    hideControlOnEnd: false,
    speed: 500,
    easing: null,
    slideMargin: 0,
    startSlide: 0,
    randomStart: false,
    captions: false,
    ticker: false,
    tickerHover: false,
    adaptiveHeight: false,
    adaptiveHeightSpeed: 500,
    video: false,
    useCSS: true,
    preloadImages: 'visible',
    responsive: true,
    slideZIndex: 50,
    wrapperClass: 'bx-wrapper',

    // TOUCH
    touchEnabled: true,
    swipeThreshold: 50,
    oneToOneTouch: true,
    preventDefaultSwipeX: true,
    preventDefaultSwipeY: false,

    // ACCESSIBILITY
    ariaLive: true,
    ariaHidden: true,

    // KEYBOARD
    keyboardEnabled: false,

    // PAGER
    pager: true,
    pagerType: 'full',
    pagerShortSeparator: ' / ',
    pagerSelector: null,
    buildPager: null,
    pagerCustom: null,

    // CONTROLS
    controls: true,
    nextText: 'Next',
    prevText: 'Prev',
    nextSelector: null,
    prevSelector: null,
    autoControls: false,
    startText: 'Start',
    stopText: 'Stop',
    autoControlsCombine: false,
    autoControlsSelector: null,

    // AUTO
    auto: false,
    pause: 4000,
    autoStart: true,
    autoDirection: 'next',
    stopAutoOnClick: false,
    autoHover: false,
    autoDelay: 0,
    autoSlideForOnePage: false,

    // CAROUSEL
    minSlides: 1,
    maxSlides: 1,
    moveSlides: 0,
    slideWidth: 0,
    shrinkItems: false,

    // CALLBACKS
    onSliderLoad: function() { return true; },
    onSlideBefore: function() { return true; },
    onSlideAfter: function() { return true; },
    onSlideNext: function() { return true; },
    onSlidePrev: function() { return true; },
    onSliderResize: function() { return true; }
  };

  $.fn.bxSlider = function(options) {

    if (this.length === 0) {
      return this;
    }

    // support multiple elements
    if (this.length > 1) {
      this.each(function() {
        $(this).bxSlider(options);
      });
      return this;
    }

    // create a namespace to be used throughout the plugin
    var sliderx = {},
    // set a reference to our slider element
    el = this,
    // get the original window dimens (thanks a lot IE)
    windowWidth = $(window).width(),
    windowHeight = $(window).height();

    // Return if slider is already initialized
    if ($(el).data('bxSlider')) { return; }

    /**
     * ===================================================================================
     * = PRIVATE FUNCTIONS
     * ===================================================================================
     */

    /**
     * Initializes namespace settings to be used throughout plugin
     */
    var init = function() {
      // Return if slider is already initialized
      if ($(el).data('bxSlider')) { return; }
      // merge user-supplied options with the defaults
      sliderx.settings = $.extend({}, defaults, options);
      // parse slideWidth setting
      sliderx.settings.slideWidth = parseInt(sliderx.settings.slideWidth);
      // store the original children
      sliderx.children = el.children(sliderx.settings.slideSelector);
      // check if actual number of slides is less than minSlides / maxSlides
      if (sliderx.children.length < sliderx.settings.minSlides) { sliderx.settings.minSlides = sliderx.children.length; }
      if (sliderx.children.length < sliderx.settings.maxSlides) { sliderx.settings.maxSlides = sliderx.children.length; }
      // if random start, set the startSlide setting to random number
      if (sliderx.settings.randomStart) { sliderx.settings.startSlide = Math.floor(Math.random() * sliderx.children.length); }
      // store active slide information
      sliderx.active = { index: sliderx.settings.startSlide };
      // store if the slider is in carousel mode (displaying / moving multiple slides)
      sliderx.carousel = sliderx.settings.minSlides > 1 || sliderx.settings.maxSlides > 1 ? true : false;
      // if carousel, force preloadImages = 'all'
      if (sliderx.carousel) { sliderx.settings.preloadImages = 'all'; }
      // calculate the min / max width thresholds based on min / max number of slides
      // used to setup and update carousel slides dimensions
      sliderx.minThreshold = (sliderx.settings.minSlides * sliderx.settings.slideWidth) + ((sliderx.settings.minSlides - 1) * sliderx.settings.slideMargin);
      sliderx.maxThreshold = (sliderx.settings.maxSlides * sliderx.settings.slideWidth) + ((sliderx.settings.maxSlides - 1) * sliderx.settings.slideMargin);
      // store the current state of the slider (if currently animating, working is true)
      sliderx.working = false;
      // initialize the controls object
      sliderx.controls = {};
      // initialize an auto interval
      sliderx.interval = null;
      // determine which property to use for transitions
      sliderx.animProp = sliderx.settings.mode === 'vertical' ? 'top' : 'left';
      // determine if hardware acceleration can be used
      sliderx.usingCSS = sliderx.settings.useCSS && sliderx.settings.mode !== 'fade' && (function() {
        // create our test div element
        var div = document.createElement('div'),
        // css transition properties
        props = ['WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];
        // test for each property
        for (var i = 0; i < props.length; i++) {
          if (div.style[props[i]] !== undefined) {
            sliderx.cssPrefix = props[i].replace('Perspective', '').toLowerCase();
            sliderx.animProp = '-' + sliderx.cssPrefix + '-transform';
            return true;
          }
        }
        return false;
      }());
      // if vertical mode always make maxSlides and minSlides equal
      if (sliderx.settings.mode === 'vertical') { sliderx.settings.maxSlides = sliderx.settings.minSlides; }
      // save original style data
      el.data('origStyle', el.attr('style'));
      el.children(sliderx.settings.slideSelector).each(function() {
        $(this).data('origStyle', $(this).attr('style'));
      });

      // perform all DOM / CSS modifications
      setup();
    };

    /**
     * Performs all DOM and CSS modifications
     */
    var setup = function() {
      var preloadSelector = sliderx.children.eq(sliderx.settings.startSlide); // set the default preload selector (visible)

      // wrap el in a wrapper
      el.wrap('<div class="' + sliderx.settings.wrapperClass + '"><div class="bx-viewport"></div></div>');
      // store a namespace reference to .bx-viewport
      sliderx.viewport = el.parent();

      // add aria-live if the setting is enabled and ticker mode is disabled
      if (sliderx.settings.ariaLive && !sliderx.settings.ticker) {
        sliderx.viewport.attr('aria-live', 'polite');
      }
      // add a loading div to display while images are loading
      sliderx.loader = $('<div class="bx-loading" />');
      sliderx.viewport.prepend(sliderx.loader);
      // set el to a massive width, to hold any needed slides
      // also strip any margin and padding from el
      el.css({
        width: sliderx.settings.mode === 'horizontal' ? (sliderx.children.length * 1000 + 215) + '%' : 'auto',
        position: 'relative'
      });
      // if using CSS, add the easing property
      if (sliderx.usingCSS && sliderx.settings.easing) {
        el.css('-' + sliderx.cssPrefix + '-transition-timing-function', sliderx.settings.easing);
      // if not using CSS and no easing value was supplied, use the default JS animation easing (swing)
      } else if (!sliderx.settings.easing) {
        sliderx.settings.easing = 'swing';
      }
      // make modifications to the viewport (.bx-viewport)
      sliderx.viewport.css({
        width: '100%',
        overflow: 'hidden',
        position: 'relative'
      });
      sliderx.viewport.parent().css({
        maxWidth: getViewportMaxWidth()
      });
      // apply css to all slider children
      sliderx.children.css({
        float: sliderx.settings.mode === 'horizontal' ? 'left' : 'none',
        listStyle: 'none',
        position: 'relative'
      });
      // apply the calculated width after the float is applied to prevent scrollbar interference
      sliderx.children.css('width', getSlideWidth());
      // if slideMargin is supplied, add the css
      if (sliderx.settings.mode === 'horizontal' && sliderx.settings.slideMargin > 0) { sliderx.children.css('marginRight', sliderx.settings.slideMargin); }
      if (sliderx.settings.mode === 'vertical' && sliderx.settings.slideMargin > 0) { sliderx.children.css('marginBottom', sliderx.settings.slideMargin); }
      // if "fade" mode, add positioning and z-index CSS
      if (sliderx.settings.mode === 'fade') {
        sliderx.children.css({
          position: 'absolute',
          zIndex: 0,
          display: 'none'
        });
        // prepare the z-index on the showing element
        sliderx.children.eq(sliderx.settings.startSlide).css({zIndex: sliderx.settings.slideZIndex, display: 'block'});
      }
      // create an element to contain all slider controls (pager, start / stop, etc)
      sliderx.controls.el = $('<div class="bx-controls" />');
      // if captions are requested, add them
      if (sliderx.settings.captions) { appendCaptions(); }
      // check if startSlide is last slide
      sliderx.active.last = sliderx.settings.startSlide === getPagerQty() - 1;
      // if video is true, set up the fitVids plugin
      if (sliderx.settings.video) { el.fitVids(); }
      if (sliderx.settings.preloadImages === 'all' || sliderx.settings.ticker) { preloadSelector = sliderx.children; }
      // only check for control addition if not in "ticker" mode
      if (!sliderx.settings.ticker) {
        // if controls are requested, add them
        if (sliderx.settings.controls) { appendControls(); }
        // if auto is true, and auto controls are requested, add them
        if (sliderx.settings.auto && sliderx.settings.autoControls) { appendControlsAuto(); }
        // if pager is requested, add it
        if (sliderx.settings.pager) { appendPager(); }
        // if any control option is requested, add the controls wrapper
        if (sliderx.settings.controls || sliderx.settings.autoControls || sliderx.settings.pager) { sliderx.viewport.after(sliderx.controls.el); }
      // if ticker mode, do not allow a pager
      } else {
        sliderx.settings.pager = false;
      }
      loadElements(preloadSelector, start);
    };

    var loadElements = function(selector, callback) {
      var total = selector.find('img:not([src=""]), iframe').length,
      count = 0;
      if (total === 0) {
        callback();
        return;
      }
      selector.find('img:not([src=""]), iframe').each(function() {
        $(this).one('load error', function() {
          if (++count === total) { callback(); }
        }).each(function() {
          if (this.complete) { $(this).trigger('load'); }
        });
      });
    };

    /**
     * Start the slider
     */
    var start = function() {
      // if infinite loop, prepare additional slides
      if (sliderx.settings.infiniteLoop && sliderx.settings.mode !== 'fade' && !sliderx.settings.ticker) {
        var slice    = sliderx.settings.mode === 'vertical' ? sliderx.settings.minSlides : sliderx.settings.maxSlides,
        sliceAppend  = sliderx.children.slice(0, slice).clone(true).addClass('bx-clone'),
        slicePrepend = sliderx.children.slice(-slice).clone(true).addClass('bx-clone');
        if (sliderx.settings.ariaHidden) {
          sliceAppend.attr('aria-hidden', true);
          slicePrepend.attr('aria-hidden', true);
        }
        el.append(sliceAppend).prepend(slicePrepend);
      }
      // remove the loading DOM element
      sliderx.loader.remove();
      // set the left / top position of "el"
      setSlidePosition();
      // if "vertical" mode, always use adaptiveHeight to prevent odd behavior
      if (sliderx.settings.mode === 'vertical') { sliderx.settings.adaptiveHeight = true; }
      // set the viewport height
      sliderx.viewport.height(getViewportHeight());
      // make sure everything is positioned just right (same as a window resize)
      el.redrawSlider();
      // onSliderLoad callback
      sliderx.settings.onSliderLoad.call(el, sliderx.active.index);
      // slider has been fully initialized
      sliderx.initialized = true;
      // bind the resize call to the window
      if (sliderx.settings.responsive) { $(window).bind('resize', resizeWindow); }
      // if auto is true and has more than 1 page, start the show
      if (sliderx.settings.auto && sliderx.settings.autoStart && (getPagerQty() > 1 || sliderx.settings.autoSlideForOnePage)) { initAuto(); }
      // if ticker is true, start the ticker
      if (sliderx.settings.ticker) { initTicker(); }
      // if pager is requested, make the appropriate pager link active
      if (sliderx.settings.pager) { updatePagerActive(sliderx.settings.startSlide); }
      // check for any updates to the controls (like hideControlOnEnd updates)
      if (sliderx.settings.controls) { updateDirectionControls(); }
      // if touchEnabled is true, setup the touch events
      if (sliderx.settings.touchEnabled && !sliderx.settings.ticker) { initTouch(); }
      // if keyboardEnabled is true, setup the keyboard events
      if (sliderx.settings.keyboardEnabled && !sliderx.settings.ticker) {
        $(document).keydown(keyPress);
      }
    };

    /**
     * Returns the calculated height of the viewport, used to determine either adaptiveHeight or the maxHeight value
     */
    var getViewportHeight = function() {
      var height = 0;
      // first determine which children (slides) should be used in our height calculation
      var children = $();
      // if mode is not "vertical" and adaptiveHeight is false, include all children
      if (sliderx.settings.mode !== 'vertical' && !sliderx.settings.adaptiveHeight) {
        children = sliderx.children;
      } else {
        // if not carousel, return the single active child
        if (!sliderx.carousel) {
          children = sliderx.children.eq(sliderx.active.index);
        // if carousel, return a slice of children
        } else {
          // get the individual slide index
          var currentIndex = sliderx.settings.moveSlides === 1 ? sliderx.active.index : sliderx.active.index * getMoveBy();
          // add the current slide to the children
          children = sliderx.children.eq(currentIndex);
          // cycle through the remaining "showing" slides
          for (i = 1; i <= sliderx.settings.maxSlides - 1; i++) {
            // if looped back to the start
            if (currentIndex + i >= sliderx.children.length) {
              children = children.add(sliderx.children.eq(i - 1));
            } else {
              children = children.add(sliderx.children.eq(currentIndex + i));
            }
          }
        }
      }
      // if "vertical" mode, calculate the sum of the heights of the children
      if (sliderx.settings.mode === 'vertical') {
        children.each(function(index) {
          height += $(this).outerHeight();
        });
        // add user-supplied margins
        if (sliderx.settings.slideMargin > 0) {
          height += sliderx.settings.slideMargin * (sliderx.settings.minSlides - 1);
        }
      // if not "vertical" mode, calculate the max height of the children
      } else {
        height = Math.max.apply(Math, children.map(function() {
          return $(this).outerHeight(false);
        }).get());
      }

      if (sliderx.viewport.css('box-sizing') === 'border-box') {
        height += parseFloat(sliderx.viewport.css('padding-top')) + parseFloat(sliderx.viewport.css('padding-bottom')) +
              parseFloat(sliderx.viewport.css('border-top-width')) + parseFloat(sliderx.viewport.css('border-bottom-width'));
      } else if (sliderx.viewport.css('box-sizing') === 'padding-box') {
        height += parseFloat(sliderx.viewport.css('padding-top')) + parseFloat(sliderx.viewport.css('padding-bottom'));
      }

      return height;
    };

    /**
     * Returns the calculated width to be used for the outer wrapper / viewport
     */
    var getViewportMaxWidth = function() {
      var width = '100%';
      if (sliderx.settings.slideWidth > 0) {
        if (sliderx.settings.mode === 'horizontal') {
          width = (sliderx.settings.maxSlides * sliderx.settings.slideWidth) + ((sliderx.settings.maxSlides - 1) * sliderx.settings.slideMargin);
        } else {
          width = sliderx.settings.slideWidth;
        }
      }
      return width;
    };

    /**
     * Returns the calculated width to be applied to each slide
     */
    var getSlideWidth = function() {
      var newElWidth = sliderx.settings.slideWidth, // start with any user-supplied slide width
      wrapWidth      = sliderx.viewport.width();    // get the current viewport width
      // if slide width was not supplied, or is larger than the viewport use the viewport width
      if (sliderx.settings.slideWidth === 0 ||
        (sliderx.settings.slideWidth > wrapWidth && !sliderx.carousel) ||
        sliderx.settings.mode === 'vertical') {
        newElWidth = wrapWidth;
      // if carousel, use the thresholds to determine the width
      } else if (sliderx.settings.maxSlides > 1 && sliderx.settings.mode === 'horizontal') {
        if (wrapWidth > sliderx.maxThreshold) {
          return newElWidth;
        } else if (wrapWidth < sliderx.minThreshold) {
          newElWidth = (wrapWidth - (sliderx.settings.slideMargin * (sliderx.settings.minSlides - 1))) / sliderx.settings.minSlides;
        } else if (sliderx.settings.shrinkItems) {
          newElWidth = Math.floor((wrapWidth + sliderx.settings.slideMargin) / (Math.ceil((wrapWidth + sliderx.settings.slideMargin) / (newElWidth + sliderx.settings.slideMargin))) - sliderx.settings.slideMargin);
        }
      }
      return newElWidth;
    };

    /**
     * Returns the number of slides currently visible in the viewport (includes partially visible slides)
     */
    var getNumberSlidesShowing = function() {
      var slidesShowing = 1,
      childWidth = null;
      if (sliderx.settings.mode === 'horizontal' && sliderx.settings.slideWidth > 0) {
        // if viewport is smaller than minThreshold, return minSlides
        if (sliderx.viewport.width() < sliderx.minThreshold) {
          slidesShowing = sliderx.settings.minSlides;
        // if viewport is larger than maxThreshold, return maxSlides
        } else if (sliderx.viewport.width() > sliderx.maxThreshold) {
          slidesShowing = sliderx.settings.maxSlides;
        // if viewport is between min / max thresholds, divide viewport width by first child width
        } else {
          childWidth = sliderx.children.first().width() + sliderx.settings.slideMargin;
          slidesShowing = Math.floor((sliderx.viewport.width() +
            sliderx.settings.slideMargin) / childWidth);
        }
      // if "vertical" mode, slides showing will always be minSlides
      } else if (sliderx.settings.mode === 'vertical') {
        slidesShowing = sliderx.settings.minSlides;
      }
      return slidesShowing;
    };

    /**
     * Returns the number of pages (one full viewport of slides is one "page")
     */
    var getPagerQty = function() {
      var pagerQty = 0,
      breakPoint = 0,
      counter = 0;
      // if moveSlides is specified by the user
      if (sliderx.settings.moveSlides > 0) {
        if (sliderx.settings.infiniteLoop) {
          pagerQty = Math.ceil(sliderx.children.length / getMoveBy());
        } else {
          // when breakpoint goes above children length, counter is the number of pages
          while (breakPoint < sliderx.children.length) {
            ++pagerQty;
            breakPoint = counter + getNumberSlidesShowing();
            counter += sliderx.settings.moveSlides <= getNumberSlidesShowing() ? sliderx.settings.moveSlides : getNumberSlidesShowing();
          }
        }
      // if moveSlides is 0 (auto) divide children length by sides showing, then round up
      } else {
        pagerQty = Math.ceil(sliderx.children.length / getNumberSlidesShowing());
      }
      return pagerQty;
    };

    /**
     * Returns the number of individual slides by which to shift the slider
     */
    var getMoveBy = function() {
      // if moveSlides was set by the user and moveSlides is less than number of slides showing
      if (sliderx.settings.moveSlides > 0 && sliderx.settings.moveSlides <= getNumberSlidesShowing()) {
        return sliderx.settings.moveSlides;
      }
      // if moveSlides is 0 (auto)
      return getNumberSlidesShowing();
    };

    /**
     * Sets the slider's (el) left or top position
     */
    var setSlidePosition = function() {
      var position, lastChild, lastShowingIndex;
      // if last slide, not infinite loop, and number of children is larger than specified maxSlides
      if (sliderx.children.length > sliderx.settings.maxSlides && sliderx.active.last && !sliderx.settings.infiniteLoop) {
        if (sliderx.settings.mode === 'horizontal') {
          // get the last child's position
          lastChild = sliderx.children.last();
          position = lastChild.position();
          // set the left position
          setPositionProperty(-(position.left - (sliderx.viewport.width() - lastChild.outerWidth())), 'reset', 0);
        } else if (sliderx.settings.mode === 'vertical') {
          // get the last showing index's position
          lastShowingIndex = sliderx.children.length - sliderx.settings.minSlides;
          position = sliderx.children.eq(lastShowingIndex).position();
          // set the top position
          setPositionProperty(-position.top, 'reset', 0);
        }
      // if not last slide
      } else {
        // get the position of the first showing slide
        position = sliderx.children.eq(sliderx.active.index * getMoveBy()).position();
        // check for last slide
        if (sliderx.active.index === getPagerQty() - 1) { sliderx.active.last = true; }
        // set the respective position
        if (position !== undefined) {
          if (sliderx.settings.mode === 'horizontal') { setPositionProperty(-position.left, 'reset', 0); }
          else if (sliderx.settings.mode === 'vertical') { setPositionProperty(-position.top, 'reset', 0); }
        }
      }
    };

    /**
     * Sets the el's animating property position (which in turn will sometimes animate el).
     * If using CSS, sets the transform property. If not using CSS, sets the top / left property.
     *
     * @param value (int)
     *  - the animating property's value
     *
     * @param type (string) 'slide', 'reset', 'ticker'
     *  - the type of instance for which the function is being
     *
     * @param duration (int)
     *  - the amount of time (in ms) the transition should occupy
     *
     * @param params (array) optional
     *  - an optional parameter containing any variables that need to be passed in
     */
    var setPositionProperty = function(value, type, duration, params) {
      var animateObj, propValue;
      // use CSS transform
      if (sliderx.usingCSS) {
        // determine the translate3d value
        propValue = sliderx.settings.mode === 'vertical' ? 'translate3d(0, ' + value + 'px, 0)' : 'translate3d(' + value + 'px, 0, 0)';
        // add the CSS transition-duration
        el.css('-' + sliderx.cssPrefix + '-transition-duration', duration / 1000 + 's');
        if (type === 'slide') {
          // set the property value
          el.css(sliderx.animProp, propValue);
          if (duration !== 0) {
            // bind a callback method - executes when CSS transition completes
            el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(e) {
              //make sure it's the correct one
              if (!$(e.target).is(el)) { return; }
              // unbind the callback
              el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');
              updateAfterSlideTransition();
            });
          } else { //duration = 0
            updateAfterSlideTransition();
          }
        } else if (type === 'reset') {
          el.css(sliderx.animProp, propValue);
        } else if (type === 'ticker') {
          // make the transition use 'linear'
          el.css('-' + sliderx.cssPrefix + '-transition-timing-function', 'linear');
          el.css(sliderx.animProp, propValue);
          if (duration !== 0) {
            el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(e) {
              //make sure it's the correct one
              if (!$(e.target).is(el)) { return; }
              // unbind the callback
              el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');
              // reset the position
              setPositionProperty(params.resetValue, 'reset', 0);
              // start the loop again
              tickerLoop();
            });
          } else { //duration = 0
            setPositionProperty(params.resetValue, 'reset', 0);
            tickerLoop();
          }
        }
      // use JS animate
      } else {
        animateObj = {};
        animateObj[sliderx.animProp] = value;
        if (type === 'slide') {
          el.animate(animateObj, duration, sliderx.settings.easing, function() {
            updateAfterSlideTransition();
          });
        } else if (type === 'reset') {
          el.css(sliderx.animProp, value);
        } else if (type === 'ticker') {
          el.animate(animateObj, duration, 'linear', function() {
            setPositionProperty(params.resetValue, 'reset', 0);
            // run the recursive loop after animation
            tickerLoop();
          });
        }
      }
    };

    /**
     * Populates the pager with proper amount of pages
     */
    var populatePager = function() {
      var pagerHtml = '',
      linkContent = '',
      pagerQty = getPagerQty();
      // loop through each pager item
      for (var i = 0; i < pagerQty; i++) {
        linkContent = '';
        // if a buildPager function is supplied, use it to get pager link value, else use index + 1
        if (sliderx.settings.buildPager && $.isFunction(sliderx.settings.buildPager) || sliderx.settings.pagerCustom) {
          linkContent = sliderx.settings.buildPager(i);
          sliderx.pagerEl.addClass('bx-custom-pager');
        } else {
          linkContent = i + 1;
          sliderx.pagerEl.addClass('bx-default-pager');
        }
        // var linkContent = sliderx.settings.buildPager && $.isFunction(sliderx.settings.buildPager) ? sliderx.settings.buildPager(i) : i + 1;
        // add the markup to the string
        pagerHtml += '<div class="bx-pager-item"><a href="" data-slide-index="' + i + '" class="bx-pager-link">' + linkContent + '</a></div>';
      }
      // populate the pager element with pager links
      sliderx.pagerEl.html(pagerHtml);
    };

    /**
     * Appends the pager to the controls element
     */
    var appendPager = function() {
      if (!sliderx.settings.pagerCustom) {
        // create the pager DOM element
        sliderx.pagerEl = $('<div class="bx-pager" />');
        // if a pager selector was supplied, populate it with the pager
        if (sliderx.settings.pagerSelector) {
          $(sliderx.settings.pagerSelector).html(sliderx.pagerEl);
        // if no pager selector was supplied, add it after the wrapper
        } else {
          sliderx.controls.el.addClass('bx-has-pager').append(sliderx.pagerEl);
        }
        // populate the pager
        populatePager();
      } else {
        sliderx.pagerEl = $(sliderx.settings.pagerCustom);
      }
      // assign the pager click binding
      sliderx.pagerEl.on('click touchend', 'a', clickPagerBind);
    };

    /**
     * Appends prev / next controls to the controls element
     */
    var appendControls = function() {
      sliderx.controls.next = $('<a class="bx-next" href="">' + sliderx.settings.nextText + '</a>');
      sliderx.controls.prev = $('<a class="bx-prev" href="">' + sliderx.settings.prevText + '</a>');
      // bind click actions to the controls
      sliderx.controls.next.bind('click touchend', clickNextBind);
      sliderx.controls.prev.bind('click touchend', clickPrevBind);
      // if nextSelector was supplied, populate it
      if (sliderx.settings.nextSelector) {
        $(sliderx.settings.nextSelector).append(sliderx.controls.next);
      }
      // if prevSelector was supplied, populate it
      if (sliderx.settings.prevSelector) {
        $(sliderx.settings.prevSelector).append(sliderx.controls.prev);
      }
      // if no custom selectors were supplied
      if (!sliderx.settings.nextSelector && !sliderx.settings.prevSelector) {
        // add the controls to the DOM
        sliderx.controls.directionEl = $('<div class="bx-controls-direction" />');
        // add the control elements to the directionEl
        sliderx.controls.directionEl.append(sliderx.controls.prev).append(sliderx.controls.next);
        // sliderx.viewport.append(sliderx.controls.directionEl);
        sliderx.controls.el.addClass('bx-has-controls-direction').append(sliderx.controls.directionEl);
      }
    };

    /**
     * Appends start / stop auto controls to the controls element
     */
    var appendControlsAuto = function() {
      sliderx.controls.start = $('<div class="bx-controls-auto-item"><a class="bx-start" href="">' + sliderx.settings.startText + '</a></div>');
      sliderx.controls.stop = $('<div class="bx-controls-auto-item"><a class="bx-stop" href="">' + sliderx.settings.stopText + '</a></div>');
      // add the controls to the DOM
      sliderx.controls.autoEl = $('<div class="bx-controls-auto" />');
      // bind click actions to the controls
      sliderx.controls.autoEl.on('click', '.bx-start', clickStartBind);
      sliderx.controls.autoEl.on('click', '.bx-stop', clickStopBind);
      // if autoControlsCombine, insert only the "start" control
      if (sliderx.settings.autoControlsCombine) {
        sliderx.controls.autoEl.append(sliderx.controls.start);
      // if autoControlsCombine is false, insert both controls
      } else {
        sliderx.controls.autoEl.append(sliderx.controls.start).append(sliderx.controls.stop);
      }
      // if auto controls selector was supplied, populate it with the controls
      if (sliderx.settings.autoControlsSelector) {
        $(sliderx.settings.autoControlsSelector).html(sliderx.controls.autoEl);
      // if auto controls selector was not supplied, add it after the wrapper
      } else {
        sliderx.controls.el.addClass('bx-has-controls-auto').append(sliderx.controls.autoEl);
      }
      // update the auto controls
      updateAutoControls(sliderx.settings.autoStart ? 'stop' : 'start');
    };

    /**
     * Appends image captions to the DOM
     */
    var appendCaptions = function() {
      // cycle through each child
      sliderx.children.each(function(index) {
        // get the image title attribute
        var title = $(this).find('img:first').attr('title');
        // append the caption
        if (title !== undefined && ('' + title).length) {
          $(this).append('<div class="bx-caption"><span>' + title + '</span></div>');
        }
      });
    };

    /**
     * Click next binding
     *
     * @param e (event)
     *  - DOM event object
     */
    var clickNextBind = function(e) {
      e.preventDefault();
      if (sliderx.controls.el.hasClass('disabled')) { return; }
      // if auto show is running, stop it
      if (sliderx.settings.auto && sliderx.settings.stopAutoOnClick) { el.stopAuto(); }
      el.goToNextSlide();
    };

    /**
     * Click prev binding
     *
     * @param e (event)
     *  - DOM event object
     */
    var clickPrevBind = function(e) {
      e.preventDefault();
      if (sliderx.controls.el.hasClass('disabled')) { return; }
      // if auto show is running, stop it
      if (sliderx.settings.auto && sliderx.settings.stopAutoOnClick) { el.stopAuto(); }
      el.goToPrevSlide();
    };

    /**
     * Click start binding
     *
     * @param e (event)
     *  - DOM event object
     */
    var clickStartBind = function(e) {
      el.startAuto();
      e.preventDefault();
    };

    /**
     * Click stop binding
     *
     * @param e (event)
     *  - DOM event object
     */
    var clickStopBind = function(e) {
      el.stopAuto();
      e.preventDefault();
    };

    /**
     * Click pager binding
     *
     * @param e (event)
     *  - DOM event object
     */
    var clickPagerBind = function(e) {
      var pagerLink, pagerIndex;
      e.preventDefault();
      if (sliderx.controls.el.hasClass('disabled')) {
        return;
      }
      // if auto show is running, stop it
      if (sliderx.settings.auto  && sliderx.settings.stopAutoOnClick) { el.stopAuto(); }
      pagerLink = $(e.currentTarget);
      if (pagerLink.attr('data-slide-index') !== undefined) {
        pagerIndex = parseInt(pagerLink.attr('data-slide-index'));
        // if clicked pager link is not active, continue with the goToSlide call
        if (pagerIndex !== sliderx.active.index) { el.goToSlide(pagerIndex); }
      }
    };

    /**
     * Updates the pager links with an active class
     *
     * @param slideIndex (int)
     *  - index of slide to make active
     */
    var updatePagerActive = function(slideIndex) {
      // if "short" pager type
      var len = sliderx.children.length; // nb of children
      if (sliderx.settings.pagerType === 'short') {
        if (sliderx.settings.maxSlides > 1) {
          len = Math.ceil(sliderx.children.length / sliderx.settings.maxSlides);
        }
        sliderx.pagerEl.html((slideIndex + 1) + sliderx.settings.pagerShortSeparator + len);
        return;
      }
      // remove all pager active classes
      sliderx.pagerEl.find('a').removeClass('active');
      // apply the active class for all pagers
      sliderx.pagerEl.each(function(i, el) { $(el).find('a').eq(slideIndex).addClass('active'); });
    };

    /**
     * Performs needed actions after a slide transition
     */
    var updateAfterSlideTransition = function() {
      // if infinite loop is true
      if (sliderx.settings.infiniteLoop) {
        var position = '';
        // first slide
        if (sliderx.active.index === 0) {
          // set the new position
          position = sliderx.children.eq(0).position();
        // carousel, last slide
        } else if (sliderx.active.index === getPagerQty() - 1 && sliderx.carousel) {
          position = sliderx.children.eq((getPagerQty() - 1) * getMoveBy()).position();
        // last slide
        } else if (sliderx.active.index === sliderx.children.length - 1) {
          position = sliderx.children.eq(sliderx.children.length - 1).position();
        }
        if (position) {
          if (sliderx.settings.mode === 'horizontal') { setPositionProperty(-position.left, 'reset', 0); }
          else if (sliderx.settings.mode === 'vertical') { setPositionProperty(-position.top, 'reset', 0); }
        }
      }
      // declare that the transition is complete
      sliderx.working = false;
      // onSlideAfter callback
      sliderx.settings.onSlideAfter.call(el, sliderx.children.eq(sliderx.active.index), sliderx.oldIndex, sliderx.active.index);
    };

    /**
     * Updates the auto controls state (either active, or combined switch)
     *
     * @param state (string) "start", "stop"
     *  - the new state of the auto show
     */
    var updateAutoControls = function(state) {
      // if autoControlsCombine is true, replace the current control with the new state
      if (sliderx.settings.autoControlsCombine) {
        sliderx.controls.autoEl.html(sliderx.controls[state]);
      // if autoControlsCombine is false, apply the "active" class to the appropriate control
      } else {
        sliderx.controls.autoEl.find('a').removeClass('active');
        sliderx.controls.autoEl.find('a:not(.bx-' + state + ')').addClass('active');
      }
    };

    /**
     * Updates the direction controls (checks if either should be hidden)
     */
    var updateDirectionControls = function() {
      if (getPagerQty() === 1) {
        sliderx.controls.prev.addClass('disabled');
        sliderx.controls.next.addClass('disabled');
      } else if (!sliderx.settings.infiniteLoop && sliderx.settings.hideControlOnEnd) {
        // if first slide
        if (sliderx.active.index === 0) {
          sliderx.controls.prev.addClass('disabled');
          sliderx.controls.next.removeClass('disabled');
        // if last slide
        } else if (sliderx.active.index === getPagerQty() - 1) {
          sliderx.controls.next.addClass('disabled');
          sliderx.controls.prev.removeClass('disabled');
        // if any slide in the middle
        } else {
          sliderx.controls.prev.removeClass('disabled');
          sliderx.controls.next.removeClass('disabled');
        }
      }
    };

    /**
     * Initializes the auto process
     */
    var initAuto = function() {
      // if autoDelay was supplied, launch the auto show using a setTimeout() call
      if (sliderx.settings.autoDelay > 0) {
        var timeout = setTimeout(el.startAuto, sliderx.settings.autoDelay);
      // if autoDelay was not supplied, start the auto show normally
      } else {
        el.startAuto();

        //add focus and blur events to ensure its running if timeout gets paused
        $(window).focus(function() {
          el.startAuto();
        }).blur(function() {
          el.stopAuto();
        });
      }
      // if autoHover is requested
      if (sliderx.settings.autoHover) {
        // on el hover
        el.hover(function() {
          // if the auto show is currently playing (has an active interval)
          if (sliderx.interval) {
            // stop the auto show and pass true argument which will prevent control update
            el.stopAuto(true);
            // create a new autoPaused value which will be used by the relative "mouseout" event
            sliderx.autoPaused = true;
          }
        }, function() {
          // if the autoPaused value was created be the prior "mouseover" event
          if (sliderx.autoPaused) {
            // start the auto show and pass true argument which will prevent control update
            el.startAuto(true);
            // reset the autoPaused value
            sliderx.autoPaused = null;
          }
        });
      }
    };

    /**
     * Initializes the ticker process
     */
    var initTicker = function() {
      var startPosition = 0,
      position, transform, value, idx, ratio, property, newSpeed, totalDimens;
      // if autoDirection is "next", append a clone of the entire slider
      if (sliderx.settings.autoDirection === 'next') {
        el.append(sliderx.children.clone().addClass('bx-clone'));
      // if autoDirection is "prev", prepend a clone of the entire slider, and set the left position
      } else {
        el.prepend(sliderx.children.clone().addClass('bx-clone'));
        position = sliderx.children.first().position();
        startPosition = sliderx.settings.mode === 'horizontal' ? -position.left : -position.top;
      }
      setPositionProperty(startPosition, 'reset', 0);
      // do not allow controls in ticker mode
      sliderx.settings.pager = false;
      sliderx.settings.controls = false;
      sliderx.settings.autoControls = false;
      // if autoHover is requested
      if (sliderx.settings.tickerHover) {
        if (sliderx.usingCSS) {
          idx = sliderx.settings.mode === 'horizontal' ? 4 : 5;
          sliderx.viewport.hover(function() {
            transform = el.css('-' + sliderx.cssPrefix + '-transform');
            value = parseFloat(transform.split(',')[idx]);
            setPositionProperty(value, 'reset', 0);
          }, function() {
            totalDimens = 0;
            sliderx.children.each(function(index) {
              totalDimens += sliderx.settings.mode === 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);
            });
            // calculate the speed ratio (used to determine the new speed to finish the paused animation)
            ratio = sliderx.settings.speed / totalDimens;
            // determine which property to use
            property = sliderx.settings.mode === 'horizontal' ? 'left' : 'top';
            // calculate the new speed
            newSpeed = ratio * (totalDimens - (Math.abs(parseInt(value))));
            tickerLoop(newSpeed);
          });
        } else {
          // on el hover
          sliderx.viewport.hover(function() {
            el.stop();
          }, function() {
            // calculate the total width of children (used to calculate the speed ratio)
            totalDimens = 0;
            sliderx.children.each(function(index) {
              totalDimens += sliderx.settings.mode === 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);
            });
            // calculate the speed ratio (used to determine the new speed to finish the paused animation)
            ratio = sliderx.settings.speed / totalDimens;
            // determine which property to use
            property = sliderx.settings.mode === 'horizontal' ? 'left' : 'top';
            // calculate the new speed
            newSpeed = ratio * (totalDimens - (Math.abs(parseInt(el.css(property)))));
            tickerLoop(newSpeed);
          });
        }
      }
      // start the ticker loop
      tickerLoop();
    };

    /**
     * Runs a continuous loop, news ticker-style
     */
    var tickerLoop = function(resumeSpeed) {
      var speed = resumeSpeed ? resumeSpeed : sliderx.settings.speed,
      position = {left: 0, top: 0},
      reset = {left: 0, top: 0},
      animateProperty, resetValue, params;

      // if "next" animate left position to last child, then reset left to 0
      if (sliderx.settings.autoDirection === 'next') {
        position = el.find('.bx-clone').first().position();
      // if "prev" animate left position to 0, then reset left to first non-clone child
      } else {
        reset = sliderx.children.first().position();
      }
      animateProperty = sliderx.settings.mode === 'horizontal' ? -position.left : -position.top;
      resetValue = sliderx.settings.mode === 'horizontal' ? -reset.left : -reset.top;
      params = {resetValue: resetValue};
      setPositionProperty(animateProperty, 'ticker', speed, params);
    };

    /**
     * Check if el is on screen
     */
    var isOnScreen = function(el) {
      var win = $(window),
      viewport = {
        top: win.scrollTop(),
        left: win.scrollLeft()
      },
      bounds = el.offset();

      viewport.right = viewport.left + win.width();
      viewport.bottom = viewport.top + win.height();
      bounds.right = bounds.left + el.outerWidth();
      bounds.bottom = bounds.top + el.outerHeight();

      return (!(viewport.right < bounds.left || viewport.left > bounds.right || viewport.bottom < bounds.top || viewport.top > bounds.bottom));
    };

    /**
     * Initializes keyboard events
     */
    var keyPress = function(e) {
      var activeElementTag = document.activeElement.tagName.toLowerCase(),
      tagFilters = 'input|textarea',
      p = new RegExp(activeElementTag,['i']),
      result = p.exec(tagFilters);

      if (result == null && isOnScreen(el)) {
        if (e.keyCode === 39) {
          clickNextBind(e);
          return false;
        } else if (e.keyCode === 37) {
          clickPrevBind(e);
          return false;
        }
      }
    };

    /**
     * Initializes touch events
     */
    var initTouch = function() {
      // initialize object to contain all touch values
      sliderx.touch = {
        start: {x: 0, y: 0},
        end: {x: 0, y: 0}
      };
      sliderx.viewport.bind('touchstart MSPointerDown pointerdown', onTouchStart);

      //for browsers that have implemented pointer events and fire a click after
      //every pointerup regardless of whether pointerup is on same screen location as pointerdown or not
      sliderx.viewport.on('click', '.bxslider a', function(e) {
        if (sliderx.viewport.hasClass('click-disabled')) {
          e.preventDefault();
          sliderx.viewport.removeClass('click-disabled');
        }
      });
    };

    /**
     * Event handler for "touchstart"
     *
     * @param e (event)
     *  - DOM event object
     */
    var onTouchStart = function(e) {
      //disable slider controls while user is interacting with slides to avoid slider freeze that happens on touch devices when a slide swipe happens immediately after interacting with slider controls
      sliderx.controls.el.addClass('disabled');

      if (sliderx.working) {
        e.preventDefault();
        sliderx.controls.el.removeClass('disabled');
      } else {
        // record the original position when touch starts
        sliderx.touch.originalPos = el.position();
        var orig = e.originalEvent,
        touchPoints = (typeof orig.changedTouches !== 'undefined') ? orig.changedTouches : [orig];
        // record the starting touch x, y coordinates
        sliderx.touch.start.x = touchPoints[0].pageX;
        sliderx.touch.start.y = touchPoints[0].pageY;

        if (sliderx.viewport.get(0).setPointerCapture) {
          sliderx.pointerId = orig.pointerId;
          sliderx.viewport.get(0).setPointerCapture(sliderx.pointerId);
        }
        // bind a "touchmove" event to the viewport
        sliderx.viewport.bind('touchmove MSPointerMove pointermove', onTouchMove);
        // bind a "touchend" event to the viewport
        sliderx.viewport.bind('touchend MSPointerUp pointerup', onTouchEnd);
        sliderx.viewport.bind('MSPointerCancel pointercancel', onPointerCancel);
      }
    };

    /**
     * Cancel Pointer for Windows Phone
     *
     * @param e (event)
     *  - DOM event object
     */
    var onPointerCancel = function(e) {
      /* onPointerCancel handler is needed to deal with situations when a touchend
      doesn't fire after a touchstart (this happens on windows phones only) */
      setPositionProperty(sliderx.touch.originalPos.left, 'reset', 0);

      //remove handlers
      sliderx.controls.el.removeClass('disabled');
      sliderx.viewport.unbind('MSPointerCancel pointercancel', onPointerCancel);
      sliderx.viewport.unbind('touchmove MSPointerMove pointermove', onTouchMove);
      sliderx.viewport.unbind('touchend MSPointerUp pointerup', onTouchEnd);
      if (sliderx.viewport.get(0).releasePointerCapture) {
        sliderx.viewport.get(0).releasePointerCapture(sliderx.pointerId);
      }
    };

    /**
     * Event handler for "touchmove"
     *
     * @param e (event)
     *  - DOM event object
     */
    var onTouchMove = function(e) {
      var orig = e.originalEvent,
      touchPoints = (typeof orig.changedTouches !== 'undefined') ? orig.changedTouches : [orig],
      // if scrolling on y axis, do not prevent default
      xMovement = Math.abs(touchPoints[0].pageX - sliderx.touch.start.x),
      yMovement = Math.abs(touchPoints[0].pageY - sliderx.touch.start.y),
      value = 0,
      change = 0;

      // x axis swipe
      if ((xMovement * 3) > yMovement && sliderx.settings.preventDefaultSwipeX) {
        e.preventDefault();
      // y axis swipe
      } else if ((yMovement * 3) > xMovement && sliderx.settings.preventDefaultSwipeY) {
        e.preventDefault();
      }
      if (sliderx.settings.mode !== 'fade' && sliderx.settings.oneToOneTouch) {
        // if horizontal, drag along x axis
        if (sliderx.settings.mode === 'horizontal') {
          change = touchPoints[0].pageX - sliderx.touch.start.x;
          value = sliderx.touch.originalPos.left + change;
        // if vertical, drag along y axis
        } else {
          change = touchPoints[0].pageY - sliderx.touch.start.y;
          value = sliderx.touch.originalPos.top + change;
        }
        setPositionProperty(value, 'reset', 0);
      }
    };

    /**
     * Event handler for "touchend"
     *
     * @param e (event)
     *  - DOM event object
     */
    var onTouchEnd = function(e) {
      sliderx.viewport.unbind('touchmove MSPointerMove pointermove', onTouchMove);
      //enable slider controls as soon as user stops interacing with slides
      sliderx.controls.el.removeClass('disabled');
      var orig    = e.originalEvent,
      touchPoints = (typeof orig.changedTouches !== 'undefined') ? orig.changedTouches : [orig],
      value       = 0,
      distance    = 0;
      // record end x, y positions
      sliderx.touch.end.x = touchPoints[0].pageX;
      sliderx.touch.end.y = touchPoints[0].pageY;
      // if fade mode, check if absolute x distance clears the threshold
      if (sliderx.settings.mode === 'fade') {
        distance = Math.abs(sliderx.touch.start.x - sliderx.touch.end.x);
        if (distance >= sliderx.settings.swipeThreshold) {
          if (sliderx.touch.start.x > sliderx.touch.end.x) {
            el.goToNextSlide();
          } else {
            el.goToPrevSlide();
          }
          el.stopAuto();
        }
      // not fade mode
      } else {
        // calculate distance and el's animate property
        if (sliderx.settings.mode === 'horizontal') {
          distance = sliderx.touch.end.x - sliderx.touch.start.x;
          value = sliderx.touch.originalPos.left;
        } else {
          distance = sliderx.touch.end.y - sliderx.touch.start.y;
          value = sliderx.touch.originalPos.top;
        }
        // if not infinite loop and first / last slide, do not attempt a slide transition
        if (!sliderx.settings.infiniteLoop && ((sliderx.active.index === 0 && distance > 0) || (sliderx.active.last && distance < 0))) {
          setPositionProperty(value, 'reset', 200);
        } else {
          // check if distance clears threshold
          if (Math.abs(distance) >= sliderx.settings.swipeThreshold) {
            if (distance < 0) {
              el.goToNextSlide();
            } else {
              el.goToPrevSlide();
            }
            el.stopAuto();
          } else {
            // el.animate(property, 200);
            setPositionProperty(value, 'reset', 200);
          }
        }
      }
      sliderx.viewport.unbind('touchend MSPointerUp pointerup', onTouchEnd);
      if (sliderx.viewport.get(0).releasePointerCapture) {
        sliderx.viewport.get(0).releasePointerCapture(sliderx.pointerId);
      }
    };

    /**
     * Window resize event callback
     */
    var resizeWindow = function(e) {
      // don't do anything if slider isn't initialized.
      if (!sliderx.initialized) { return; }
      // Delay if slider working.
      if (sliderx.working) {
        window.setTimeout(resizeWindow, 10);
      } else {
        // get the new window dimens (again, thank you IE)
        var windowWidthNew = $(window).width(),
        windowHeightNew = $(window).height();
        // make sure that it is a true window resize
        // *we must check this because our dinosaur friend IE fires a window resize event when certain DOM elements
        // are resized. Can you just die already?*
        if (windowWidth !== windowWidthNew || windowHeight !== windowHeightNew) {
          // set the new window dimens
          windowWidth = windowWidthNew;
          windowHeight = windowHeightNew;
          // update all dynamic elements
          el.redrawSlider();
          // Call user resize handler
          sliderx.settings.onSliderResize.call(el, sliderx.active.index);
        }
      }
    };

    /**
     * Adds an aria-hidden=true attribute to each element
     *
     * @param startVisibleIndex (int)
     *  - the first visible element's index
     */
    var applyAriaHiddenAttributes = function(startVisibleIndex) {
      var numberOfSlidesShowing = getNumberSlidesShowing();
      // only apply attributes if the setting is enabled and not in ticker mode
      if (sliderx.settings.ariaHidden && !sliderx.settings.ticker) {
        // add aria-hidden=true to all elements
        sliderx.children.attr('aria-hidden', 'true');
        // get the visible elements and change to aria-hidden=false
        sliderx.children.slice(startVisibleIndex, startVisibleIndex + numberOfSlidesShowing).attr('aria-hidden', 'false');
      }
    };

    /**
     * Returns index according to present page range
     *
     * @param slideOndex (int)
     *  - the desired slide index
     */
    var setSlideIndex = function(slideIndex) {
      if (slideIndex < 0) {
        if (sliderx.settings.infiniteLoop) {
          return getPagerQty() - 1;
        }else {
          //we don't go to undefined slides
          return sliderx.active.index;
        }
      // if slideIndex is greater than children length, set active index to 0 (this happens during infinite loop)
      } else if (slideIndex >= getPagerQty()) {
        if (sliderx.settings.infiniteLoop) {
          return 0;
        } else {
          //we don't move to undefined pages
          return sliderx.active.index;
        }
      // set active index to requested slide
      } else {
        return slideIndex;
      }
    };

    /**
     * ===================================================================================
     * = PUBLIC FUNCTIONS
     * ===================================================================================
     */

    /**
     * Performs slide transition to the specified slide
     *
     * @param slideIndex (int)
     *  - the destination slide's index (zero-based)
     *
     * @param direction (string)
     *  - INTERNAL USE ONLY - the direction of travel ("prev" / "next")
     */
    el.goToSlide = function(slideIndex, direction) {
      // onSlideBefore, onSlideNext, onSlidePrev callbacks
      // Allow transition canceling based on returned value
      var performTransition = true,
      moveBy = 0,
      position = {left: 0, top: 0},
      lastChild = null,
      lastShowingIndex, eq, value, requestEl;
      // store the old index
      sliderx.oldIndex = sliderx.active.index;
      //set new index
      sliderx.active.index = setSlideIndex(slideIndex);

      // if plugin is currently in motion, ignore request
      if (sliderx.working || sliderx.active.index === sliderx.oldIndex) { return; }
      // declare that plugin is in motion
      sliderx.working = true;

      performTransition = sliderx.settings.onSlideBefore.call(el, sliderx.children.eq(sliderx.active.index), sliderx.oldIndex, sliderx.active.index);

      // If transitions canceled, reset and return
      if (typeof (performTransition) !== 'undefined' && !performTransition) {
        sliderx.active.index = sliderx.oldIndex; // restore old index
        sliderx.working = false; // is not in motion
        return;
      }

      if (direction === 'next') {
        // Prevent canceling in future functions or lack there-of from negating previous commands to cancel
        if (!sliderx.settings.onSlideNext.call(el, sliderx.children.eq(sliderx.active.index), sliderx.oldIndex, sliderx.active.index)) {
          performTransition = false;
        }
      } else if (direction === 'prev') {
        // Prevent canceling in future functions or lack there-of from negating previous commands to cancel
        if (!sliderx.settings.onSlidePrev.call(el, sliderx.children.eq(sliderx.active.index), sliderx.oldIndex, sliderx.active.index)) {
          performTransition = false;
        }
      }

      // check if last slide
      sliderx.active.last = sliderx.active.index >= getPagerQty() - 1;
      // update the pager with active class
      if (sliderx.settings.pager || sliderx.settings.pagerCustom) { updatePagerActive(sliderx.active.index); }
      // // check for direction control update
      if (sliderx.settings.controls) { updateDirectionControls(); }
      // if slider is set to mode: "fade"
      if (sliderx.settings.mode === 'fade') {
        // if adaptiveHeight is true and next height is different from current height, animate to the new height
        if (sliderx.settings.adaptiveHeight && sliderx.viewport.height() !== getViewportHeight()) {
          sliderx.viewport.animate({height: getViewportHeight()}, sliderx.settings.adaptiveHeightSpeed);
        }
        // fade out the visible child and reset its z-index value
        sliderx.children.filter(':visible').fadeOut(sliderx.settings.speed).css({zIndex: 0});
        // fade in the newly requested slide
        sliderx.children.eq(sliderx.active.index).css('zIndex', sliderx.settings.slideZIndex + 1).fadeIn(sliderx.settings.speed, function() {
          $(this).css('zIndex', sliderx.settings.slideZIndex);
          updateAfterSlideTransition();
        });
      // slider mode is not "fade"
      } else {
        // if adaptiveHeight is true and next height is different from current height, animate to the new height
        if (sliderx.settings.adaptiveHeight && sliderx.viewport.height() !== getViewportHeight()) {
          sliderx.viewport.animate({height: getViewportHeight()}, sliderx.settings.adaptiveHeightSpeed);
        }
        // if carousel and not infinite loop
        if (!sliderx.settings.infiniteLoop && sliderx.carousel && sliderx.active.last) {
          if (sliderx.settings.mode === 'horizontal') {
            // get the last child position
            lastChild = sliderx.children.eq(sliderx.children.length - 1);
            position = lastChild.position();
            // calculate the position of the last slide
            moveBy = sliderx.viewport.width() - lastChild.outerWidth();
          } else {
            // get last showing index position
            lastShowingIndex = sliderx.children.length - sliderx.settings.minSlides;
            position = sliderx.children.eq(lastShowingIndex).position();
          }
          // horizontal carousel, going previous while on first slide (infiniteLoop mode)
        } else if (sliderx.carousel && sliderx.active.last && direction === 'prev') {
          // get the last child position
          eq = sliderx.settings.moveSlides === 1 ? sliderx.settings.maxSlides - getMoveBy() : ((getPagerQty() - 1) * getMoveBy()) - (sliderx.children.length - sliderx.settings.maxSlides);
          lastChild = el.children('.bx-clone').eq(eq);
          position = lastChild.position();
        // if infinite loop and "Next" is clicked on the last slide
        } else if (direction === 'next' && sliderx.active.index === 0) {
          // get the last clone position
          position = el.find('> .bx-clone').eq(sliderx.settings.maxSlides).position();
          sliderx.active.last = false;
        // normal non-zero requests
        } else if (slideIndex >= 0) {
          //parseInt is applied to allow floats for slides/page
          requestEl = slideIndex * parseInt(getMoveBy());
          position = sliderx.children.eq(requestEl).position();
        }

        /* If the position doesn't exist
         * (e.g. if you destroy the slider on a next click),
         * it doesn't throw an error.
         */
        if (typeof (position) !== 'undefined') {
          value = sliderx.settings.mode === 'horizontal' ? -(position.left - moveBy) : -position.top;
          // plugin values to be animated
          setPositionProperty(value, 'slide', sliderx.settings.speed);
        } else {
          sliderx.working = false;
        }
      }
      if (sliderx.settings.ariaHidden) { applyAriaHiddenAttributes(sliderx.active.index * getMoveBy()); }
    };

    /**
     * Transitions to the next slide in the show
     */
    el.goToNextSlide = function() {
      // if infiniteLoop is false and last page is showing, disregard call
      if (!sliderx.settings.infiniteLoop && sliderx.active.last) { return; }
      var pagerIndex = parseInt(sliderx.active.index) + 1;
      el.goToSlide(pagerIndex, 'next');
    };

    /**
     * Transitions to the prev slide in the show
     */
    el.goToPrevSlide = function() {
      // if infiniteLoop is false and last page is showing, disregard call
      if (!sliderx.settings.infiniteLoop && sliderx.active.index === 0) { return; }
      var pagerIndex = parseInt(sliderx.active.index) - 1;
      el.goToSlide(pagerIndex, 'prev');
    };

    /**
     * Starts the auto show
     *
     * @param preventControlUpdate (boolean)
     *  - if true, auto controls state will not be updated
     */
    el.startAuto = function(preventControlUpdate) {
      // if an interval already exists, disregard call
      if (sliderx.interval) { return; }
      // create an interval
      sliderx.interval = setInterval(function() {
        if (sliderx.settings.autoDirection === 'next') {
          el.goToNextSlide();
        } else {
          el.goToPrevSlide();
        }
      }, sliderx.settings.pause);
      // if auto controls are displayed and preventControlUpdate is not true
      if (sliderx.settings.autoControls && preventControlUpdate !== true) { updateAutoControls('stop'); }
    };

    /**
     * Stops the auto show
     *
     * @param preventControlUpdate (boolean)
     *  - if true, auto controls state will not be updated
     */
    el.stopAuto = function(preventControlUpdate) {
      // if no interval exists, disregard call
      if (!sliderx.interval) { return; }
      // clear the interval
      clearInterval(sliderx.interval);
      sliderx.interval = null;
      // if auto controls are displayed and preventControlUpdate is not true
      if (sliderx.settings.autoControls && preventControlUpdate !== true) { updateAutoControls('start'); }
    };

    /**
     * Returns current slide index (zero-based)
     */
    el.getCurrentSlide = function() {
      return sliderx.active.index;
    };

    /**
     * Returns current slide element
     */
    el.getCurrentSlideElement = function() {
      return sliderx.children.eq(sliderx.active.index);
    };

    /**
     * Returns a slide element
     * @param index (int)
     *  - The index (zero-based) of the element you want returned.
     */
    el.getSlideElement = function(index) {
      return sliderx.children.eq(index);
    };

    /**
     * Returns number of slides in show
     */
    el.getSlideCount = function() {
      return sliderx.children.length;
    };

    /**
     * Return sliderx.working variable
     */
    el.isWorking = function() {
      return sliderx.working;
    };

    /**
     * Update all dynamic slider elements
     */
    el.redrawSlider = function() {
      // resize all children in ratio to new screen size
      sliderx.children.add(el.find('.bx-clone')).outerWidth(getSlideWidth());
      // adjust the height
      sliderx.viewport.css('height', getViewportHeight());
      // update the slide position
      if (!sliderx.settings.ticker) { setSlidePosition(); }
      // if active.last was true before the screen resize, we want
      // to keep it last no matter what screen size we end on
      if (sliderx.active.last) { sliderx.active.index = getPagerQty() - 1; }
      // if the active index (page) no longer exists due to the resize, simply set the index as last
      if (sliderx.active.index >= getPagerQty()) { sliderx.active.last = true; }
      // if a pager is being displayed and a custom pager is not being used, update it
      if (sliderx.settings.pager && !sliderx.settings.pagerCustom) {
        populatePager();
        updatePagerActive(sliderx.active.index);
      }
      if (sliderx.settings.ariaHidden) { applyAriaHiddenAttributes(sliderx.active.index * getMoveBy()); }
    };

    /**
     * Destroy the current instance of the slider (revert everything back to original state)
     */
    el.destroySlider = function() {
      // don't do anything if slider has already been destroyed
      if (!sliderx.initialized) { return; }
      sliderx.initialized = false;
      $('.bx-clone', this).remove();
      sliderx.children.each(function() {
        if ($(this).data('origStyle') !== undefined) {
          $(this).attr('style', $(this).data('origStyle'));
        } else {
          $(this).removeAttr('style');
        }
      });
      if ($(this).data('origStyle') !== undefined) {
        this.attr('style', $(this).data('origStyle'));
      } else {
        $(this).removeAttr('style');
      }
      $(this).unwrap().unwrap();
      if (sliderx.controls.el) { sliderx.controls.el.remove(); }
      if (sliderx.controls.next) { sliderx.controls.next.remove(); }
      if (sliderx.controls.prev) { sliderx.controls.prev.remove(); }
      if (sliderx.pagerEl && sliderx.settings.controls && !sliderx.settings.pagerCustom) { sliderx.pagerEl.remove(); }
      $('.bx-caption', this).remove();
      if (sliderx.controls.autoEl) { sliderx.controls.autoEl.remove(); }
      clearInterval(sliderx.interval);
      if (sliderx.settings.responsive) { $(window).unbind('resize', resizeWindow); }
      if (sliderx.settings.keyboardEnabled) { $(document).unbind('keydown', keyPress); }
      //remove self reference in data
      $(this).removeData('bxSlider');
    };

    /**
     * Reload the slider (revert all DOM changes, and re-initialize)
     */
    el.reloadSlider = function(settings) {
      if (settings !== undefined) { options = settings; }
      el.destroySlider();
      init();
      //store reference to self in order to access public functions later
      $(el).data('bxSlider', this);
    };

    init();

    $(el).data('bxSlider', this);

    // returns the current jQuery object
    return this;
  };

})(jQuery);
